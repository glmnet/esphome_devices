# This node controls remote startup and shutdown of a gasoline electricity generator
substitutions:
  device_name: eh-generador
  friendly_name: Generador

packages:
  board: !include .pkg.esp32.arduino.yaml
  home: !include .pkg.home.yaml
  wifi: !include .pkg.wifi.yaml

esphome:
  on_boot:
    # make sure choke is open position, if for some reason generator starts and the thing reboots this will make it run smooth.
    - delay: 2s
    - servo.write:
        id: choke_valve
        level: 30%
  on_loop:
    - if:
        condition:
          - lambda: |-
              return id(log_counter) > 0 ? id(log_counter)-- : 0;
        then:
          - lambda: "id(v_batt).update();"
          - logger.log:
              level: info
              format: "%d v_batt: %.3f"
              args: [id(log_counter), id(v_batt).state]

logger:
  level: DEBUG
  logs:
    pulse_counter: INFO
    sensor: INFO
    adc: INFO
    sim800l: DEBUG

globals:
  - id: log_counter
    type: int
    restore_value: no
    initial_value: "0"

wifi:
  reboot_timeout: 0s

uart:
  - id: sim800l_uart
    baud_rate: 9600
    tx_pin: GPIO17
    rx_pin: GPIO16
  - id: pm_uart
    baud_rate: 9600
    tx_pin: GPIO10
    rx_pin: GPIO14

sim800l:
  uart_id: sim800l_uart
  on_sms_received:
    - logger.log:
        format: "Received '%s' from %s"
        args: ["message.c_str()", "sender.c_str()"]
    - lambda: |-
        id(sms_sender).publish_state(sender);
        id(sms_message).publish_state(message);

    # locally handle Generator commands
    - if:
        condition:
          or:
            - text_sensor.state:
                id: sms_sender
                state: !secret glm_phone_number
            - text_sensor.state:
                id: sms_sender
                state: !secret clau_phone_number
        then:
          - if:
              condition:
                text_sensor.state:
                  id: sms_message
                  state: "Generador encender"
              then:
                script.execute: turn_on
          - if:
              condition:
                - text_sensor.state:
                    id: sms_message
                    state: "Generador apagar"
              then:
                script.execute: turn_off
  on_incoming_call:
    - logger.log:
        format: "Incoming call from '%s'"
        args: ["caller_id.c_str()"]
    - lambda: |-
        id(caller_id_text_sensor).publish_state(caller_id);
    - delay: 1s
    - sim800l.disconnect:
  on_call_connected:
    - logger.log:
        format: "*************** call connected"
    - if:
        condition:
          - switch.is_on: auto_disconnect_call
        then:
          - logger.log:
              format: "*************** auto disconnecting..."
          - sim800l.disconnect

  on_call_disconnected:
    - logger.log: "*************** call disconnected"
  on_ussd_received:
    - logger.log:
        format: "Received '%s'"
        args: ["ussd.c_str()"]
    - lambda: |-
        id(ussd_message).publish_state(ussd);

switch:
  - platform: template
    name: "Auto disconnect call"
    id: auto_disconnect_call
    optimistic: True

text_sensor:
  - platform: template
    id: sms_sender
    name: "Sms Sender"
  - platform: template
    id: sms_message
    name: "Sms Message"
  - platform: template
    id: caller_id_text_sensor
    name: "Caller ID"
  - platform: template
    id: ussd_message
    name: "Ussd Code"

api:
  reboot_timeout: 0s
  services:
    - service: send_sms
      variables:
        recipient: string
        message: string
      then:
        - sim800l.send_sms:
            recipient: !lambda return recipient;
            message: !lambda return message;

    - service: dial
      variables:
        recipient: string
      then:
        sim800l.dial:
          recipient: !lambda "return recipient;"
    - service: connect
      then:
        - sim800l.connect:
    - service: disconnect
      then:
        - sim800l.disconnect:
    # - service: send_ussd
    #   then:
    #     - sim800l.send_ussd:
    #         ussd: "*111#"

    - service: turn_on
      then:
        - script.execute: turn_on
    - service: turn_off
      then:
        - script.execute: turn_off
    - service: dump_batt_voltage
      then:
        - globals.set:
            id: log_counter
            value: "300"
    - service: set_servo
      variables:
        servo_percent: int
      then:
        servo.write:
          id: choke_valve
          level: !lambda |-
            // this is a c comment
            return servo_percent / 100.0;
    - service: open_choke
      then:
        - script.execute: open_choke
    - service: close_choke
      then:
        - script.execute: close_choke

dallas:
  pin: GPIO22

output:
  - platform: gpio
    id: carburator_fuel_valve
    pin: GPIO4 # relay 1
    inverted: true
  - platform: gpio
    id: ignition_ground
    pin:
      number: GPIO0 # relay 2
      ignore_strapping_warning: true
    inverted: true
  - platform: gpio
    id: starter_coil
    pin: # GPIO2 # relay 3
      number: GPIO2
      ignore_strapping_warning: true
    inverted: true

  - platform: gpio
    id: battery_saver
    pin:
      number: GPIO15 # relay 4
      ignore_strapping_warning: true
    inverted: true

  - platform: ledc
    frequency: 50 Hz
    id: choke_valve_output
    pin: GPIO23

servo:
  id: choke_valve
  output: choke_valve_output
  auto_detach_time: 1s
  transition_length: 400ms

sensor:
  - platform: template
    lambda: "return id(generador_on).state ? 1 : 0;"
    id: generador_accum_encendido

  - platform: integration
    name: Generador Tiempo encendido total
    device_class: duration
    state_class: total_increasing
    unit_of_measurement: s
    time_unit: s
    restore: True
    sensor: generador_accum_encendido

  - platform: dallas
    index: 0
    name: Generador Temperatura Motor
    filters:
      - filter_out: 85.0

  - platform: adc
    pin: GPIO39
    id: v_fuente
    unit_of_measurement: V
    state_class: measurement
    name: Generador Voltage Fuente
    update_interval: 2s # should update every 30s due to the filter
    filters:
      # 33k / 1k5  -> (33k + 1k5) / 1k5 = 23
      - multiply: 23.0
      - sliding_window_moving_average:
    accuracy_decimals: 3
  - platform: adc
    pin: GPIO36
    id: v_batt
    unit_of_measurement: V
    state_class: measurement
    name: Generador Voltage Bateria
    update_interval: 2s # should update every 30s due to the filter
    filters:
      # 33k / 1k5  -> (33k + 1k5) / 1k5 = 23
      - multiply: 23.0
      - sliding_window_moving_average:
    accuracy_decimals: 3
  # there is a pin connected to the spark plug ignition coil open terminal
  # (used to stop the engine by grounding it)

  # via optocoupler pulses low on every spark

  - platform: pulse_counter
    pin: GPIO34
    id: engine_rpm_instant
    update_interval: 300ms
    count_mode:
      falling_edge: INCREMENT
      rising_edge: DISABLE

  - platform: template
    id: engine_rpm_instant_public
    name: Generador Motor RPM
    unit_of_measurement: RPM
    state_class: measurement
    lambda: !lambda return id(engine_rpm_instant).state;
    update_interval: never

  - platform: sim800l
    rssi:
      name: Generador RSSI
  - platform: pzemac
    id: pzem1
    address: 0xF8
    voltage:
      name: Generador voltage
      filters:
        - lambda: "if (x > 2000000) return {}; return x;"
    current:
      name: Generador corriente
      filters:
        - lambda: "if (x > 2000000) return {}; return x;"
    energy:
      name: Generador energia
      filters:
        - lambda: "if (x > 2000000) return {}; return x;"
    power:
      name: Generador potencia
      filters:
        - lambda: "if (x > 2000000) return {}; return x;"
    frequency:
      name: Generador frecuencia
      filters:
        - lambda: "if (x > 2000000) return {}; return x;"
    power_factor:
      name: Generador factor potencia
      filters:
        - lambda: "if (x > 2000000) return {}; return x;"
    update_interval: never

modbus:
  # used by pzemac
  - uart_id: pm_uart

script:
  - id: open_choke # Open is for normal generator run
    then:
      # slowly open guarantees smooth startup
      - servo.write:
          id: choke_valve
          level: -65%
      - delay: 60ms
      - servo.write:
          id: choke_valve
          level: -45%
      - delay: 60ms
      - servo.write:
          id: choke_valve
          level: -35%
      - delay: 70ms
      - servo.write:
          id: choke_valve
          level: -5%
      - delay: 200ms
      - servo.write:
          id: choke_valve
          level: 15%
      - delay: 200ms
      - servo.write:
          id: choke_valve
          level: 30%
  - id: close_choke # Close is for startup only
    then:
      - servo.write:
          id: choke_valve
          level: -5%
      - delay: 100ms
      - servo.write:
          id: choke_valve
          level: -85%

  - id: starter_max_time
    mode: single
    then:
      - delay: 5s
      - logger.log:
          format: "Tiempo arranque agotado"
          level: info

  - id: turn_on
    then:
      - logger.log:
          format: "Arrancando generador..."
          level: info
      - output.turn_off: ignition_ground
      - output.turn_off: carburator_fuel_valve
      - servo.write:
          id: choke_valve
          level: 15%
      - delay: 200ms
      - script.execute: close_choke
      - delay: 500ms
      - logger.log:
          format: "Comando arranque..."
          level: info
      - script.execute: starter_max_time
      - output.turn_on: starter_coil
      - wait_until:
          or:
            - not:
                script.is_running: starter_max_time
            - for:
                time: 0.7s
                condition:
                  - sensor.in_range:
                      id: engine_rpm_instant
                      above: 700

      - logger.log:
          level: INFO
          format: "RPM encendido detectado"
      - output.turn_off: starter_coil

      # check if timed out
      - if:
          condition:
            not:
              script.is_running: starter_max_time
          then:
            - script.execute: open_choke
            - logger.log:
                level: INFO
                format: "Generador no arranco"
            - script.stop: turn_on

      - delay: 600ms
      - script.execute: open_choke

      - logger.log:
          level: INFO
          format: "Generador arranque normal completo"

  - id: turn_off
    then:
      - logger.log: "Stopping generator..."
      - output.turn_on: carburator_fuel_valve
      - delay: 1s
      - output.turn_on: ignition_ground
      - delay: 10s
      - output.turn_off: carburator_fuel_valve
      - output.turn_off: ignition_ground

binary_sensor:
  - platform: template
    id: generador_on
    name: Generador Encendido
    lambda: !lambda return id(engine_rpm_instant).state > 2700;
  - platform: gpio
    pin: GPIO35
    id: start_switch
    on_press:
      - logger.log:
          level: INFO
          format: "start switch"
      - globals.set:
          id: log_counter
          value: "300"
  - platform: template
    id: on_ac_power
  - platform: sim800l
    registered:
      name: Generador Registrado red celular

interval:
  # battery saver
  - interval: 1s
    then:
      - if:
          condition:
            - sensor.in_range:
                id: v_fuente
                above: 11.0
          then:
            output.turn_on: battery_saver
          else:
            if:
              condition:
                for:
                  time: 1 min
                  condition:
                    sensor.in_range:
                      id: v_batt
                      below: 11.5
              then:
                - logger.log:
                    level: WARN
                    format: Shutting down due to battery LOW
                - delay: 2s
                - output.turn_off: battery_saver
  - interval: 5s
    then:
      if:
        condition:
          - binary_sensor.is_on: generador_on
        then:
          - component.update: pzem1

  - interval: 5s
    then:
      if:
        condition:
          or:
            - sensor.in_range:
                id: engine_rpm_instant_public
                above: 0
            - sensor.in_range:
                id: engine_rpm_instant
                above: 0
        then:
          sensor.template.publish:
            id: engine_rpm_instant_public
            state: !lambda return id(engine_rpm_instant).state;

button:
  - platform: template
    name: Generador reiniciar contador energia
    on_press:
      then:
        - pzemac.reset_energy: pzem1
